### 设计模式

```python
# 接口 若干抽象方法的集合
from abc import ABCMeta
# 面向对象设计原则
--- SOLID
'''
1. 开放封闭原则
2. 里氏替换原则：所有引用父类的地方必须能透明的使用其子类方法
3. 以来倒置原则：高层模块不应该依赖底层模块 二者都依赖抽象
			  抽象不依赖细节 细节依赖抽象 
4. 接口隔离原则：使用多个接口 而不是单一接口
5. 单一职责原则：不要存在多于一个导致类变更的原因
'''
```

### 创建型模式

#### 简单工厂模式

```python
'''
不直接向客户端暴露对象创建的实现细节 而是通过一个工厂类来负责创建产品类的实例

工厂角色
抽象产品角色
具体产品角色

优点：隐藏了对象创建的实现细节
	 客户端不需要修改代码
缺点：违反了单一职责原则，将创建逻辑集中到一个工厂类中
	 当添加新产品时 需要修改工厂类代码 违反了开闭原则
'''
```

####  工厂方法模式

```python
'''
定义一个用于创建对象的接口（工厂接口）让子类决定实例化哪一个产品类

抽象工厂角色
具体工厂角色
抽象产品角色
具体产品角色

优点：每个具体产品都对应一个具体工厂类 不需要修改工厂类代码
	 隐藏了对象创建的实现细节
缺点：每增加一个具体产品类 就必须增加一个相应的具体工厂类
'''
```

#### 抽象工厂模式

```python
'''
定义一个工厂类接口，让工厂子类来创建一系列相关或相互依赖的对象

抽象工厂角色
具体工厂角色
抽象产品角色
具体产品角色

优点：将客户端鱼类的具体实现分离
	 每个工厂创建了一个完整额产品系列 使得易于交换产品系列
	 有利于产品的一致性
缺点：难以支持新种类的产品
'''
```

#### 建造者模式

```python
'''
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

抽象建造者
具体建造者
指挥者
产品

优点：隐藏了一个产品的内部结构和装配过程
	 将构造代码和表示代码分开
	 可以对构造过程进行更精细的控制
'''
```

#### 单例模式

```python
'''
保证一个类只有一个实例
		
优点：对唯一实例的受控访问
	 单例相当于全局变量 但防止了命名空间被污染
'''
class Singleton:
	def __new__(cls, *args, **kwargs):
		if not hasattr(cls, "_instance"):
			cls._instance = super(Singleton, cls).__new__(cls)
		return cls._instance
```

### 结构型模式

#### 适配器模式

```python
'''
将一个类的接口转换成酷虎希望的另一个接口 适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

两种实现方式：
 类适配器 ： 使用多继承
 对象适配器 : 使用组合
'''
# 类适配器
class NewBankPay(Payment, BankPay):
	def pay(self, money):
		self.cost(money)
 # 对象适配器
class PaymentAdapter(Payment):
    def __init__(self, payment):
        self.payment = payment
        
    def pay(self, money):
        self.payment.cost(money)
```

#### 桥模式

```python
'''
将一个事物的俩个维度分离 使其都可以独立的变化

优点：抽象和实现分离
	 优秀的拓展能力
'''
```

#### 组合模式

```python
'''
将对象组合成树形结构以表示 整体-部分 的层次结构 组合模式使得用户对单个对象和组合对象得使用具有一致性

抽象组件
叶子组件
复合组件
客户端
'''

```



### 行为型模式



